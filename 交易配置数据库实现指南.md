# 交易配置数据库实现指南

## 一、快速开始

### 1.1 执行SQL脚本
```bash
# 执行数据库表创建脚本
mysql -u用户名 -p数据库名 < 交易配置数据库表结构.sql
```

### 1.2 验证表结构
```sql
-- 查看表结构
DESC trade_config;

-- 查看表注释
SHOW CREATE TABLE trade_config;

-- 查看默认数据
SELECT * FROM trade_config WHERE id = 1;
```

## 二、后端实现要点

### 2.1 单例模式实现

由于配置表采用单例模式（只有一条记录，id=1），后端实现需要注意：

```java
// 示例：Java Spring Boot 实现

// 1. 查询配置（固定查询id=1）
TradeConfigDO config = tradeConfigMapper.selectById(1);
if (config == null) {
    // 初始化配置
    config = new TradeConfigDO();
    config.setId(1L);
    // ... 设置默认值
    tradeConfigMapper.insert(config);
}

// 2. 更新配置（固定更新id=1）
TradeConfigDO updateConfig = new TradeConfigDO();
updateConfig.setId(1L);
// ... 设置更新字段
tradeConfigMapper.updateById(updateConfig);
```

### 2.2 金额字段转换

**所有金额字段都需要转换**（前端元 → 后端分）：

```java
// 保存时：元 → 分
public TradeConfigDO convertToDO(TradeConfigVO vo) {
    TradeConfigDO config = new TradeConfigDO();
    
    // 同城配送金额字段
    if (vo.getSameCityStartPrice() != null) {
        config.setSameCityStartPrice(vo.getSameCityStartPrice().multiply(new BigDecimal("100")).longValue());
    }
    if (vo.getSameCityExtraPrice() != null) {
        config.setSameCityExtraPrice(vo.getSameCityExtraPrice().multiply(new BigDecimal("100")).longValue());
    }
    // ... 其他金额字段
    
    return config;
}

// 查询时：分 → 元
public TradeConfigVO convertToVO(TradeConfigDO config) {
    TradeConfigVO vo = new TradeConfigVO();
    
    // 同城配送金额字段
    if (config.getSameCityStartPrice() != null) {
        vo.setSameCityStartPrice(new BigDecimal(config.getSameCityStartPrice()).divide(new BigDecimal("100"), 2, RoundingMode.HALF_UP));
    }
    if (config.getSameCityExtraPrice() != null) {
        vo.setSameCityExtraPrice(new BigDecimal(config.getSameCityExtraPrice()).divide(new BigDecimal("100"), 2, RoundingMode.HALF_UP));
    }
    // ... 其他金额字段
    
    return vo;
}
```

### 2.3 JSON字段处理

```java
// MySQL JSON字段自动映射
@TableField(typeHandler = JacksonTypeHandler.class)
private List<String> afterSaleRefundReasons;

// 或者使用TypeHandler
@TableField(typeHandler = Fastjson2TypeHandler.class)
private List<String> afterSaleRefundReasons;
```

### 2.4 坐标字段验证

```java
// 验证坐标范围
public void validateCoordinates(BigDecimal latitude, BigDecimal longitude) {
    if (latitude != null) {
        if (latitude.compareTo(new BigDecimal("-90")) < 0 || 
            latitude.compareTo(new BigDecimal("90")) > 0) {
            throw new IllegalArgumentException("纬度范围必须在-90到90之间");
        }
    }
    if (longitude != null) {
        if (longitude.compareTo(new BigDecimal("-180")) < 0 || 
            longitude.compareTo(new BigDecimal("180")) > 0) {
            throw new IllegalArgumentException("经度范围必须在-180到180之间");
        }
    }
}
```

## 三、数据校验规则

### 3.1 业务校验

```java
// 示例：校验同城配送配置
public void validateSameCityConfig(TradeConfigVO config) {
    // 校验金额字段 >= 0
    if (config.getSameCityStartPrice() != null && 
        config.getSameCityStartPrice().compareTo(BigDecimal.ZERO) < 0) {
        throw new IllegalArgumentException("起步价不能小于0");
    }
    
    // 校验距离字段 >= 0
    if (config.getSameCityStartDistance() != null && 
        config.getSameCityStartDistance().compareTo(BigDecimal.ZERO) < 0) {
        throw new IllegalArgumentException("起步距离不能小于0");
    }
    
    // 校验百分比字段范围 0-100
    if (config.getBrokerageFirstPercent() != null) {
        if (config.getBrokerageFirstPercent() < 0 || 
            config.getBrokerageFirstPercent() > 100) {
            throw new IllegalArgumentException("一级返佣比例必须在0-100之间");
        }
    }
    
    // 校验计费方式
    Integer chargeMode = config.getSameCityChargeMode();
    if (chargeMode != null && chargeMode < 1 || chargeMode > 3) {
        throw new IllegalArgumentException("计费方式必须在1-3之间");
    }
}
```

## 四、常见问题

### 4.1 金额精度问题

**问题**：前端显示金额时出现精度误差（如0.1 + 0.2 = 0.30000000000000004）

**解决**：
```java
// 使用BigDecimal进行金额计算
BigDecimal price1 = new BigDecimal("0.1");
BigDecimal price2 = new BigDecimal("0.2");
BigDecimal result = price1.add(price2); // 0.3

// 转换为分时，注意精度控制
long cents = price.multiply(new BigDecimal("100"))
                  .setScale(0, RoundingMode.HALF_UP)
                  .longValue();
```

### 4.2 JSON字段查询

**问题**：如何查询JSON数组字段？

**解决**：
```sql
-- MySQL JSON函数查询
SELECT * FROM trade_config 
WHERE JSON_CONTAINS(after_sale_refund_reasons, '"不想要了"');

-- 使用JSON_EXTRACT
SELECT JSON_EXTRACT(after_sale_refund_reasons, '$[0]') AS first_reason;
```

### 4.3 单例模式并发更新

**问题**：多线程同时更新配置可能产生数据不一致

**解决**：
```java
// 使用乐观锁或分布式锁
@Transactional
public void updateConfig(TradeConfigVO vo) {
    // 方案1：乐观锁（需要添加version字段）
    TradeConfigDO config = tradeConfigMapper.selectById(1);
    config.setVersion(config.getVersion() + 1);
    // ... 更新字段
    int rows = tradeConfigMapper.updateById(config);
    if (rows == 0) {
        throw new OptimisticLockException("配置已被其他线程更新，请刷新后重试");
    }
    
    // 方案2：分布式锁
    String lockKey = "trade_config:update";
    RLock lock = redisson.getLock(lockKey);
    try {
        lock.lock(10, TimeUnit.SECONDS);
        // ... 更新逻辑
    } finally {
        lock.unlock();
    }
}
```

## 五、性能优化建议

### 5.1 缓存配置

配置数据不频繁变化，建议使用缓存：

```java
@Cacheable(value = "tradeConfig", key = "'config:1'")
public TradeConfigVO getConfig() {
    // 查询配置
}

@CacheEvict(value = "tradeConfig", key = "'config:1'")
public void updateConfig(TradeConfigVO vo) {
    // 更新配置
}
```

### 5.2 字段选择

查询时只选择需要的字段，避免查询所有字段：

```java
// 只查询需要的字段
TradeConfigDO config = tradeConfigMapper.selectOne(
    new LambdaQueryWrapper<TradeConfigDO>()
        .eq(TradeConfigDO::getId, 1L)
        .select(TradeConfigDO::getSameCityChargeMode,
                TradeConfigDO::getSameCityStartPrice)
);
```

## 六、数据迁移

如果已有配置数据需要迁移：

```sql
-- 1. 备份旧表
CREATE TABLE trade_config_backup AS SELECT * FROM trade_config_old;

-- 2. 执行新的表结构
-- （执行交易配置数据库表结构.sql）

-- 3. 数据迁移（需要编写迁移脚本）
INSERT INTO trade_config (
    id,
    after_sale_refund_reasons,
    -- ... 其他字段
    delivery_express_free_price
) 
SELECT 
    1,
    JSON_ARRAY('不想要了', '买错了'), -- 转换旧数据格式
    -- ... 其他字段转换
    old_free_price * 100 -- 金额转换：元 → 分
FROM trade_config_old;
```

## 七、测试建议

### 7.1 单元测试

```java
@Test
public void testAmountConversion() {
    // 测试金额转换：元 → 分
    BigDecimal yuan = new BigDecimal("10.50");
    long cents = yuan.multiply(new BigDecimal("100")).longValue();
    assertEquals(1050L, cents);
    
    // 测试金额转换：分 → 元
    long cents2 = 1050L;
    BigDecimal yuan2 = new BigDecimal(cents2).divide(new BigDecimal("100"), 2, RoundingMode.HALF_UP);
    assertEquals(new BigDecimal("10.50"), yuan2);
}
```

### 7.2 集成测试

```java
@Test
public void testConfigSaveAndQuery() {
    // 保存配置
    TradeConfigVO config = new TradeConfigVO();
    config.setSameCityStartPrice(new BigDecimal("10.00"));
    // ... 设置其他字段
    configService.saveConfig(config);
    
    // 查询配置
    TradeConfigVO queriedConfig = configService.getConfig();
    assertEquals(new BigDecimal("10.00"), queriedConfig.getSameCityStartPrice());
}
```

## 八、监控建议

### 8.1 配置变更日志

记录配置变更历史，便于问题追踪：

```java
@Aspect
public class ConfigChangeLogAspect {
    @AfterReturning("@annotation(ConfigChange)")
    public void logConfigChange(JoinPoint joinPoint) {
        // 记录配置变更日志
        // 包括：操作人、变更时间、变更字段、变更前值、变更后值
    }
}
```

### 8.2 配置校验告警

对关键配置进行校验，异常时告警：

```java
@Scheduled(cron = "0 0 * * * ?") // 每小时检查一次
public void validateConfig() {
    TradeConfigVO config = configService.getConfig();
    
    // 检查异常配置
    if (config.getSameCityStartPrice() != null && 
        config.getSameCityStartPrice().compareTo(BigDecimal.ZERO) <= 0) {
        // 发送告警通知
        alertService.sendAlert("同城配送起步价配置异常");
    }
}
```

